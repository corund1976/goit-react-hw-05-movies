===================== М А Р Ш Р У Т И З А Ц И Я =======================

Концепция SPA (Single Page Application) и CSR (Client Side Rendering).
HTML5 History API
React Router https://v5.reactrouter.com/web/guides/primary-components
Компонент BrowserRouter https://v5.reactrouter.com/web/api/BrowserRouter

Меню навигации
==Компонент Link https://v5.reactrouter.com/web/api/Link
==Компонент NavLink https://v5.reactrouter.com/web/api/NavLink
==Оформление и проп exact https://v5.reactrouter.com/web/api/NavLink/exact-bool

Компонент Route https://v5.reactrouter.com/web/api/Route
Обработка 404
Компонент Switch https://v5.reactrouter.com/web/api/Switch
Динамические URL-параметры
==Делаем вложенную навигацию c useRouteMatch
==Свойство match.url
==Маршрут одной книги с useParams

Вложенные маршруты
==Вложенная навигация по авторам
==Вложенный маршрут автора с match.path

Маршруты
/ - приветственная страница
/authors - все авторы
/authors/:authorId - автор и его книги
/books - все книги
/books/:bookId - одна книга

=================== Р А З Д Е Л Е Н И Е \/ К О Д А ===================

Параметры адресной строки c useLocation
Программная навигация с useHistory
Повторное использование кода

Разделение кода
==Вкладка Coverage
==Динамический импорт модулей
====React.lazy()
====Webpack magic comments import('путь' /_ webpackChunkName: "имя" _/)
====React.Suspense и fallback

Допмат
==Предварительная загрузка ссылок https://web.dev/quicklink/

================ Д О П О Л Н И Т Е Л Ь Н О Е \/ З А Н Я Т И Е ===================
Слаги
==https://dev.to/fayazara/this-free-tools-for-developers-are-45p3
==slugify https://www.npmjs.com/package/slugify
==regexp101 https://regex101.com/

На каникулы
==React Query https://react-query.tanstack.com/
====Ищите туториалы по react query v3
==React Hook Form https://react-hook-form.com/

=========================== L i n k \/ N a v L i n k=====================================
Испозьзуются для вложенной навигации

<Link exact to="/" className={s.link}>Главная</Link>
<NavLink to="/authors" className={s.link} activeClassName={s.activeLink}>Авторы</NavLink>

============================== R o u t e \/ S w i t c h =====================================
BrowserRouter следит за состоянием адресной строки. Содержимое адресной строки изменяется
при клике по Link или NavLink. При изменении адресной строки BrowserRouter парсит ее (разбирает,
что там внутри) и через контекст "в глубину" прокидывает все необходимые данные. Компонент Route
подписан на контекст BrowserRouter. Под капотом он сравнивает, что ему прокинет BrowserRouter
и значение пропа "path=". Route смотрит путь - сопадает ли точно или начинается "на" и рендерит
или не рендерит компонент, который оборачивает.
<Switch>
..<Route path="/" exact>
....<HomeView />
..</Route>
..<Route path="/authors"> //Авторы
....<Authors />
..</Route>
..<Route path="/books"> //Книги
....<Authors />
..</Route>
..<Route path="/books/:bookId"> //Детали книга
....<Authors />
..</Route>
..<Route>
....<NotFoundView />
..</Route>
</Switch>
Свойство динамического параметра пути пишем после слеш с двоеточием ":" path="/books/:bookId".
Это имя (/:bookId) будет названием свойства обьекта в будущем.
Компонент Route рендерит компонент путь которого совпал с текущим адресом. Если маршруту не
передать path, он будет рендериться на всё! Группу маршрутов оборачиваем в Switch.
Компонент Switch перебирает маршруты сверху вниз до первого совпадения с текущим адресом.
И рендерит первый совпавший. Дальше по списку - не смотрит.

====================================== M A T C H ==============================================
Хук useMatch() возвращает объект со служебной информацией, который текущий компонент совпал
с адресной строкой.
const match = useRouteMatch();
const { url } = useRouteMatch();
Он показывает - точное сопадение "isExact"? У него есть также 2 свойства: path и url.
Для навигации Link используем url - это текущий путь, по которому мы находимся. А для маршрутов
используем path - это то, что ему передал Route в качестве динамического параметра (после /:)

{isExact: true

-> params: {}
path: "/books123"
url: "/books123"}

Для маршрутов (Route) используем path, а для навигации (Link) - url

==================================== P A R A M S ================================================
Хук useParams() возвращает объект с динамическими параметрами. Динамические параметры -
const params = useParams();
const { bookId } = useParams();

{bookId: "3"}

Название параметра bookId - это то, как мы назвали его в Route. А его значение "3" берется из
адресной строки. Тип данных здесь - СТРОКА !

============================== L A Z Y =====================================
Заменяем статический импорт на динамический с помощью "обертки" в Реакте.
Функция lazy работает так => когда маршрут совпадает с URL в адресной строке,
эта функция вызывает анонимку, а та в сою очередь вызывает импорт. Импорт возвращает
промис с дефолтным экспортом из указанного модуля, где будет наш код JS с "страницей".
Экспорт должен быть только дефолтный и это должен быть только компонент!!! Например,
const HomeView = lazy(() => import('./views/HomeView.js'));
В нашем случае берем дефолтный экспорт с index.js в папке каждого компонента

=============== W E B P A C K _ M A G I C _ C O M M E N T S ===================
Именованные "чанки". Когда мы делаем динамический импорт, WebPack даёт файлам номера -
от 1 до бесконечности.Чтобы имена файлов, в которые разбивались чанки, имели логически
понятные имена, при импорте в комментарии нужно добавить желаемое название. Например,
import('путь' /_ webpackChunkName: "имя" _/) или
import('./views/HomeView.js' /_ webpackChunkName: "home-view" _/)
Прежде всего это будет удобно ПОТОМ - при дебаге, для отлова ошибок.

=========================== S U S P E N S E ===================================
В будущем у Реакта будет "Suspense API" для асинхронного рендера компонентов.
React lazy и react Suspense - это его маленькие части, которые УЖЕ работают.
Пока "ленивый" компонент находится в состоянии загрузки, необходимо поставить
прелоадер или превью этого компонента. Делается это с помомщью встроенного в Реакт
компонента Suspense. Он должен оборачить то место, где используется "ленивый" код.
В нашем случае - это целиком Switch, т.к. в нём практически всё - "ленивое".
Suspense имеет обязательный проп - fallback. В него передаем любой КОМПОНЕНТ,
который будет рендериться во время загрузки асинхронного кода.
Не ссылку на компонент, а именно JSX !!! Например,
<Suspense fallback={<Loader />} или
<Suspense fallback={<h1>ЗАГРУЖАЕМ...</h1>}
